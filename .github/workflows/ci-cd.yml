# Give your workflow a name
name: Hello App CI/CD

# Define the trigger: run this workflow on any push to the 'main' branch
on:
  push:
    branches: [ "main" ]

# Define the jobs that will run
jobs:
  # --- The "Build" Job ---
  build:
    # Use a standard Ubuntu runner provided by GitHub
    runs-on: ubuntu-latest

    steps:
      # 1. Check out the code from your repository
      - name: Checkout code
        uses: actions/checkout@v3

      # 2. Log in to Docker Hub using secrets
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 3. Build and push the Docker image
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: . # Use the current directory for the build
          file: ./app-pipeline/k8s/Dockerfile # Specify the path to your Dockerfile
          push: true # Push the image to the registry
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/hello-k8s-app:latest

  # --- The "Deploy" Job ---
  deploy:
    # This job depends on the "build" job completing successfully
    needs: build
    runs-on: ubuntu-latest

    steps:
      # 1. Check out the code from your repository
      - name: Checkout code
        uses: actions/checkout@v3

      # 2. "Deploy" by showing the manifest
      # Note: Since our cluster is on your local machine (Minikube),
      # this cloud-based runner can't connect to it.
      # We'll simulate the deploy step by printing the config file.
      - name: Print Kubernetes manifest
        run: |
          echo "Applying Kubernetes manifest..."

